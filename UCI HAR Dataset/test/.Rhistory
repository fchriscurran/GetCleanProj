by(as.numeric(as.character(mergeddata$Gross.domestic.product.2012)),mergeddata$Income.Group, mean)
by(as.numeric(as.character(mergeddata$Gross.domestic.product.2012)),mergeddata$Income.Group, mean, na.rm=TRUE)
mergeddata$groups <- cut(mergeddata$Gross.domestic.product.2012, breaks=quantile(as.numeric(as.character(mergeddata$Gross.domestic.product.2012)))
)
mergeddata$groups <- cut(as.numeric(as.character(mergeddata$Gross.domestic.product.2012)), breaks=quantile(as.numeric(as.character(mergeddata$Gross.domestic.product.2012)))
)
mergeddata$groups <- cut(as.numeric(as.character(mergeddata$Gross.domestic.product.2012)), breaks=quantile(as.numeric(as.character(mergeddata$Gross.domestic.product.2012), na.rm=TRUE))
)
mergeddata$groups <- cut(as.numeric(as.character(mergeddata$Gross.domestic.product.2012)), breaks=quantile(as.numeric(as.character(mergeddata$Gross.domestic.product.2012)), na.rm=TRUE))
View(mergeddata)
View(mergeddata)
table(mergeddata$groups, mergeddata$Income.Group)
table(mergeddata$groups, mergeddata$Income.Group)
?quantile
mergeddata$groups <- cut(as.numeric(as.character(mergeddata$Gross.domestic.product.2012)), breaks=quantile(as.numeric(as.character(mergeddata$Gross.domestic.product.2012)),probs = seq(0, 1, 0.20), na.rm=TRUE))
table(mergeddata$groups, mergeddata$Income.Group)
data2 <- read.csv("https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv", header=TRUE)
data2$agricultureLogical <- data2[,"ACR"==3 & "AGS" == 6]
which(data2$agricultureLogical)
View(ed_data)
data2 <- read.csv("https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv", header=TRUE)
data2$agricultureLogical <- data2[,"ACR"==3 & "AGS" == 6]
View(data2)
View(data2)
?which
data2$agricultureLogical <- which(data2[,"ACR"==3 & "AGS" == 6])
data2$agricultureLogical <- data2[,which("ACR"==3 & "AGS" == 6])
data2$agricultureLogical <- data2[,which("ACR"==3 & "AGS" == 6)]
View(data2)
View(data2)
data2$agricultureLogical
data3 <- data2[,which("ACR"==3 & "AGS" == 6)]
data3
data2$agricultureLogical = ifelse(data2$ACR==3 & data2$AGS == 6, TRUE, FALSE)
data2$agricultureLogical
which(agricultureLogical)
which(data2$agricultureLogical)
mat1 <- matrix(c(1,2,3,4),2,2)
mat1
solve(mat1)
cacheSolve(mat1)
## The two functions below allow for the calculating and caching of
#matrix inverses.  Broadly, the cacheSolve function checks for a
#cached matrix and returns one if found.  Otherwise, it calls
#functions in the makeCacheMatrix to solve for the inverse
## The makeCacheMatrix function has subfunctions that can calculate
#the inverse of the matrix, return a cached inverse, or save a calculated
#inverse into the cache
makeCacheMatrix <- function(x = matrix()) {
}m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
## The cacheSolve function checks to see if the inverse is
# cached.  If so, it returns the cached inverse.  If not, it
#calls functions from above to calculate the inverse
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
#Pull the inverse from the getinverse() function above
m <- x$getinverse()
#if the inverse is not null, then pull the cached version
if(!is.null(m)) {
message("getting cached inverse")
return(m)
}
#if not cached, pull in the matrix and calculate the inverse
data <- x$get()
m <- solve(data)
#set the inverse in the cache and return the inverse
x$setinverse(m)
m
}
mat1 <- matrix(c(1,2,3,4),2,2)
cacheSolve(mat1)
## The two functions below allow for the calculating and caching of
#matrix inverses.  Broadly, the cacheSolve function checks for a
#cached matrix and returns one if found.  Otherwise, it calls
#functions in the makeCacheMatrix to solve for the inverse
## The makeCacheMatrix function has subfunctions that can calculate
#the inverse of the matrix, return a cached inverse, or save a calculated
#inverse into the cache
makeCacheMatrix <- function(x = matrix()) {
}m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
## The cacheSolve function checks to see if the inverse is
# cached.  If so, it returns the cached inverse.  If not, it
#calls functions from above to calculate the inverse
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
#Pull the inverse from the getinverse() function above
m <- getinverse(x)
#if the inverse is not null, then pull the cached version
if(!is.null(m)) {
message("getting cached inverse")
return(m)
}
#if not cached, pull in the matrix and calculate the inverse
data <- x$get()
m <- solve(data)
#set the inverse in the cache and return the inverse
x$setinverse(m)
m
}
mat1 <- matrix(c(1,2,3,4),2,2)
cacheSolve(mat1)
## The two functions below allow for the calculating and caching of
#matrix inverses.  Broadly, the cacheSolve function checks for a
#cached matrix and returns one if found.  Otherwise, it calls
#functions in the makeCacheMatrix to solve for the inverse
## The makeCacheMatrix function has subfunctions that can calculate
#the inverse of the matrix, return a cached inverse, or save a calculated
#inverse into the cache
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function checks to see if the inverse is
# cached.  If so, it returns the cached inverse.  If not, it
#calls functions from above to calculate the inverse
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
#Pull the inverse from the getinverse() function above
m <- getinverse(x)
#if the inverse is not null, then pull the cached version
if(!is.null(m)) {
message("getting cached inverse")
return(m)
}
#if not cached, pull in the matrix and calculate the inverse
data <- x$get()
m <- solve(data)
#set the inverse in the cache and return the inverse
x$setinverse(m)
m
}
mat1 <- matrix(c(1,2,3,4),2,2)
cacheSolve(mat1)
## The two functions below allow for the calculating and caching of
#matrix inverses.  Broadly, the cacheSolve function checks for a
#cached matrix and returns one if found.  Otherwise, it calls
#functions in the makeCacheMatrix to solve for the inverse
## The makeCacheMatrix function has subfunctions that can calculate
#the inverse of the matrix, return a cached inverse, or save a calculated
#inverse into the cache
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function checks to see if the inverse is
# cached.  If so, it returns the cached inverse.  If not, it
#calls functions from above to calculate the inverse
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
#Pull the inverse from the getinverse() function above
m <- x$getinverse()
#if the inverse is not null, then pull the cached version
if(!is.null(m)) {
message("getting cached inverse")
return(m)
}
#if not cached, pull in the matrix and calculate the inverse
data <- x$get()
m <- solve(data)
#set the inverse in the cache and return the inverse
x$setinverse(m)
m
}
mat1 <- matrix(c(1,2,3,4),2,2)
cacheSolve(mat1)
## The two functions below allow for the calculating and caching of
#matrix inverses.  Broadly, the cacheSolve function checks for a
#cached matrix and returns one if found.  Otherwise, it calls
#functions in the makeCacheMatrix to solve for the inverse
## The makeCacheMatrix function has subfunctions that can calculate
#the inverse of the matrix, return a cached inverse, or save a calculated
#inverse into the cache
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function checks to see if the inverse is
# cached.  If so, it returns the cached inverse.  If not, it
#calls functions from above to calculate the inverse
cacheSolve <- function(x = matrix(), ...) {
## Return a matrix that is the inverse of 'x'
#Pull the inverse from the getinverse() function above
m <- x$getinverse()
#if the inverse is not null, then pull the cached version
if(!is.null(m)) {
message("getting cached inverse")
return(m)
}
#if not cached, pull in the matrix and calculate the inverse
data <- x$get()
m <- solve(data)
#set the inverse in the cache and return the inverse
x$setinverse(m)
m
}
mat1 <- matrix(c(1,2,3,4),2,2)
cacheSolve(mat1)
## The two functions below allow for the calculating and caching of
#matrix inverses.  Broadly, the cacheSolve function checks for a
#cached matrix and returns one if found.  Otherwise, it calls
#functions in the makeCacheMatrix to solve for the inverse
## The makeCacheMatrix function has subfunctions that can calculate
#the inverse of the matrix, return a cached inverse, or save a calculated
#inverse into the cache
makeCacheMatrix <- function(x=matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function checks to see if the inverse is
# cached.  If so, it returns the cached inverse.  If not, it
#calls functions from above to calculate the inverse
cacheSolve <- function(x = matrix(), ...) {
## Return a matrix that is the inverse of 'x'
#Pull the inverse from the getinverse() function above
m <- x$getinverse()
#if the inverse is not null, then pull the cached version
if(!is.null(m)) {
message("getting cached inverse")
return(m)
}
#if not cached, pull in the matrix and calculate the inverse
data <- x$get()
m <- solve(data)
#set the inverse in the cache and return the inverse
x$setinverse(m)
m
}
mat1 <- matrix(c(1,2,3,4),2,2)
makeCacheMatrix(mat1)
## The two functions below allow for the calculating and caching of
#matrix inverses.  Broadly, the cacheSolve function checks for a
#cached matrix and returns one if found.  Otherwise, it calls
#functions in the makeCacheMatrix to solve for the inverse
## The makeCacheMatrix function has subfunctions that can calculate
#the inverse of the matrix, return a cached inverse, or save a calculated
#inverse into the cache
makeCacheMatrix <- function(x=matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function checks to see if the inverse is
# cached.  If so, it returns the cached inverse.  If not, it
#calls functions from above to calculate the inverse
cacheSolve <- function(x = matrix(), ...) {
## Return a matrix that is the inverse of 'x'
#Pull the inverse from the getinverse() function above
m <- x$getinverse()
#if the inverse is not null, then pull the cached version
if(!is.null(m)) {
message("getting cached inverse")
return(m)
}
#if not cached, pull in the matrix and calculate the inverse
data <- x$get()
m <- solve(data)
#set the inverse in the cache and return the inverse
x$setinverse(m)
m
}
mat1 <- matrix(c(1,2,3,4),2,2)
makeCacheMatrix(mat1)
cacheSolve(mat1)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
myvector <- c(1,2,3)
cachemean(myvector)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
myvector <- c(1,2,3)
makeVector(myvector)
cachemean(myvector)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
myvector <- c(1,2,3)
myvector2 <- makeVector(myvector)
cachemean(myvector2)
## The two functions below allow for the calculating and caching of
#matrix inverses.  Broadly, the cacheSolve function checks for a
#cached matrix and returns one if found.  Otherwise, it calls
#functions in the makeCacheMatrix to solve for the inverse
## The makeCacheMatrix function has subfunctions that can calculate
#the inverse of the matrix, return a cached inverse, or save a calculated
#inverse into the cache
makeCacheMatrix <- function(x=matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function checks to see if the inverse is
# cached.  If so, it returns the cached inverse.  If not, it
#calls functions from above to calculate the inverse
cacheSolve <- function(x = matrix(), ...) {
## Return a matrix that is the inverse of 'x'
#Pull the inverse from the getinverse() function above
m <- x$getinverse()
#if the inverse is not null, then pull the cached version
if(!is.null(m)) {
message("getting cached inverse")
return(m)
}
#if not cached, pull in the matrix and calculate the inverse
data <- x$get()
m <- solve(data)
#set the inverse in the cache and return the inverse
x$setinverse(m)
m
}
mat1 <- matrix(c(1,2,3,4),2,2)
mat2<- makeCacheMatrix(mat1)
cacheSolve(mat2)
setwd "C:\Users\Chris Curran.ThinkPadCC\Documents\Data Science Cousera\Getting and Cleaning Data\getdata_projectfiles_UCI HAR Dataset\UCI HAR Dataset"
setwd "C:/Users/Chris Curran.ThinkPadCC/Documents/Data Science Cousera/Getting and Cleaning Data/getdata_projectfiles_UCI HAR Dataset/UCI HAR Dataset/"
setwd "C:/Users/Chris Curran.ThinkPadCC/Documents/Data Science Cousera/Getting and Cleaning Data/getdata_projectfiles_UCI HAR Dataset/UCI HAR Dataset/"
setwd("C:/Users/Chris Curran.ThinkPadCC/Documents/Data Science Cousera/Getting and Cleaning Data/getdata_projectfiles_UCI HAR Dataset/UCI HAR Dataset/")
features<- read.table("features.txt", sep=" ")
View(features)
#read in train data
setwd("C:/Users/Chris Curran.ThinkPadCC/Documents/Data Science Cousera/Getting and Cleaning Data/getdata_projectfiles_UCI HAR Dataset/UCI HAR Dataset/train/")
X_train <- read.table("X_train.txt", sep=" ")
?read.table
X_train <- read.table("X_train.txt", sep=" ", na.strings=TRUE)
X_train <- read.table("X_train.txt", sep=" ", na.strings=TRUE)
X_train <- read.table("X_train.txt")
View(X_train)
View(X_train)
colnames(X_train) <features.V2
colnames(X_train) <features$V2
View(X_train)
View(X_train)
colnames(X_train) <-features$V2
View(X_train)
View(X_train)
Y_train <- read.table("y_train.txt")
View(Y_train)
View(Y_train)
#Add the Y_Train numbers to the X_train data
X_train$activitynumber < Y_train
df <- data.frame(Y_train, X_train)
View(df)
View(df)
test_df <- data.frame(Y_test, X_test)
setwd("C:/Users/Chris Curran.ThinkPadCC/Documents/Data Science Cousera/Getting and Cleaning Data/getdata_projectfiles_UCI HAR Dataset/UCI HAR Dataset/")
features<- read.table("features.txt", sep=" ")
#read in train data
setwd("C:/Users/Chris Curran.ThinkPadCC/Documents/Data Science Cousera/Getting and Cleaning Data/getdata_projectfiles_UCI HAR Dataset/UCI HAR Dataset/train/")
X_train <- read.table("X_train.txt")
#apply variable labels to the train data
colnames(X_train) <-features$V2
Y_train <- read.table("y_train.txt")
#Add the Y_Train numbers to the X_train data
colnames(Y_train) <- c("activitynumber")
train_df <- data.frame(Y_train, X_train)
setwd("C:/Users/Chris Curran.ThinkPadCC/Documents/Data Science Cousera/Getting and Cleaning Data/getdata_projectfiles_UCI HAR Dataset/UCI HAR Dataset/test/")
X_test <- read.table("X_test.txt")
#apply variable labels to the test data
colnames(X_test) <-features$V2
Y_test <- read.table("y_test.txt")
#Add the Y_test numbers to the X_test data
colnames(Y_test) <- c("activitynumber")
test_df <- data.frame(Y_test, X_test)
View(test_df)
View(test_df)
View(train_df)
View(train_df)
subject_train <- read.table("subject_train")
subject_train <- read.table("subject_test")
setwd("C:/Users/Chris Curran.ThinkPadCC/Documents/Data Science Cousera/Getting and Cleaning Data/getdata_projectfiles_UCI HAR Dataset/UCI HAR Dataset/test/")
subject_train <- read.table("subject_test")
subject_train <- read.table("subject_test.txt")
View(subject_train)
View(subject_train)
View(subject_train)
View(subject_train)
